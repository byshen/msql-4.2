/*
** Copyright (c) 1995-2001  Hughes Technologies Pty Ltd.  All rights
** reserved.  
**
** Terms under which this software may be used or copied are
** provided in the  specific license associated with this product.
**
** Hughes Technologies disclaims all warranties with regard to this 
** software, including all implied warranties of merchantability and 
** fitness, in no event shall Hughes Technologies be liable for any 
** special, indirect or consequential damages or any damages whatsoever 
** resulting from loss of use, data or profits, whether in an action of 
** contract, negligence or other tortious action, arising out of or in 
** connection with the use or performance of this software.
**
**
** $Id: yaccer.y,v 1.28 2012/01/15 06:19:59 bambi Exp $
**
*/

/*
** Module	: main : msqld_yacc
** Purpose	: YACC grammer for parsing our SQL subset
** Exports	: 
** Depends Upon	: 
*/


%{

/**************************************************************************
** STANDARD INCLUDES
**************************************************************************/

#include <common/config.h>

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif
#ifdef HAVE_STRING_H
#  include <string.h>
#endif

#include <common/portability.h>

/**************************************************************************
** MODULE SPECIFIC INCLUDES
**************************************************************************/

#include <common/msql_defs.h>
#include <libmsql/msql.h>
#include <msqld/index/index.h>
#include <msqld/includes/msqld.h>
#include <msqld/main/main.h>
#include <msqld/main/util.h>
#include <msqld/main/parse.h>
#include <msqld/main/lexer.h>
#include <msqld/main/funct.h>
#include <msqld/main/memory.h>


/**************************************************************************
** GLOBAL VARIABLES
**************************************************************************/

mQuery_t	*curQuery;		/* Set by parseQuery */
extern		int yytoklen;		/* from msqld_lex.c */
extern  	u_char *yytext;
extern		msqld *globalServer;	/* from main.c */

static	char	*charArrayLength;
static	int	notNullFlag = 0,
		keyFlag = 0;

#ifdef YYSTYPE
#  undef YYSTYPE
#endif
typedef u_char * C_PTR;
#define YYSTYPE C_PTR

int yylex();
void yyerror();

/**************************************************************************
** PRIVATE ROUTINES
**************************************************************************/


/**************************************************************************
** PUBLIC ROUTINES
**************************************************************************/


%}

%token  END_OF_INPUT

%token	GE
%token	LE
%token	NE
%token	EQ
%token	GT
%token	LT
%token	BETWEEN

%token	MSQL_CREATE
%token	MSQL_DROP
%token	MSQL_INSERT
%token	MSQL_DELETE
%token	MSQL_SELECT
%token	MSQL_UPDATE

%token	ALL
%token	DISTINCT
%token	AS

%token	WHERE
%token	ORDER
%token	FROM
%token	INTO
%token	TABLE
%token	BY
%token	ASC
%token	DESC
%token	LIKE
%token	RLIKE
%token	CLIKE
%token	SLIKE
%token	AND
%token	OR
%token	VALUES
%token	SET

%token	NOT
%token	NULLSYM

%token	PRIMARY
%token	KEY
%token	INDEX
%token	UNIQUE
%token	ON

%token	IDENT
%token	SET_FUNCT
%token	SYS_VAR
%token	NUM
%token	REAL_NUM

%token	MSQL_INT
%token	MSQL_INT8
%token	MSQL_INT16
%token	MSQL_INT32
%token	MSQL_INT64
%token	MSQL_UINT
%token	MSQL_UINT8
%token	MSQL_UINT16
%token	MSQL_UINT32
%token	MSQL_UINT64
%token	MSQL_BOOL
%token	MSQL_CHAR
%token	MSQL_TEXT
%token	MSQL_REAL
%token	MSQL_DATE
%token	MSQL_DATETIME
%token	MSQL_MILLITIME
%token	MSQL_MILLIDATETIME
%token	MSQL_MONEY
%token	MSQL_TIME
%token	MSQL_IPV4
%token	MSQL_IPV6
%token	MSQL_CIDR4
%token	MSQL_CIDR6

%token  LIMIT
%token  OFFSET

%token  CREATE_TABLE
%token  CREATE_INDEX
%token  CREATE_SEQUENCE

%token	DROP_TABLE
%token	DROP_INDEX
%token  DROP_SEQUENCE

%token	SEQUENCE
%token	VALUE
%token	STEP

%token	AVL_INDEX
%token	CPI_INDEX

%%

/*
** High level definitions
**
** Note : The lex input routines return a flag character of \001 to
** 	indicate the end of input.  This allows me to force a query
**	to be terminated at a know point (ie. the end of the query-buf)
**	Without this something like "select * from foo ;" is found by
**	yacc to be a legit query followed by a second query containing
**	only a ';' character.  The flag is generated by msqlInput() and
**	msqlFlexInput() in msql_io.c
*/

query
	: /* NULL */
	| verb_clause END_OF_INPUT
	;

verb_clause
	: create
	| select
	| drop
	| insert
	| update
	| delete
	;


/*
** Create : create database tables
*/


create
	: MSQL_CREATE create_types
	;


create_types
	: TABLE ident '(' 
		{
			curQuery->command = CREATE_TABLE;
			if (parseAddTable((char*)$2,NULL,curQuery) < 0)
                        {
				memFreeToken($2);
                                parseCleanQuery(curQuery);
                                return(-1);
                        }
			memFreeToken($2);
		}
	  field_list ')'
	| opt_unique opt_index_type INDEX ident ON ident 
		{
			curQuery->command = CREATE_INDEX;
			if (parseAddIndex((char*)$4,(char*)$6,(long)$1,(long)$2,curQuery) < 0)
                        {
				memFreeToken($4);
				memFreeToken($6);
                                parseCleanQuery(curQuery);
                                return(-1);
                        }
			memFreeToken($4);
			memFreeToken($6);
		}
	  '(' index_list ')'
	| SEQUENCE ON ident opt_seq_step opt_seq_val
		{
			curQuery->command = CREATE_SEQUENCE;
			parseAddSequence((char*)$3, (long)$4, (long)$5, curQuery);
			memFreeToken($3);
		}
	;


index_list
	: ident
		{
			if (parseAddField(parseCreateIdent(NULL, (char*)$1,
				curQuery), 0,NULL, 0,0,curQuery)<0)
			{
				parseCleanQuery(curQuery);
				memFreeToken($1);
				return(-1);
			}
			memFreeToken($1);
		}
	| index_list ',' ident
		{
			if (parseAddField(parseCreateIdent(NULL, (char*)$3, 
				curQuery), 0,NULL, 0,0,curQuery)<0)
			{
				parseCleanQuery(curQuery);
				memFreeToken($3);
				return(-1);
			}
			memFreeToken($3);
		}
	;

opt_unique
	: UNIQUE
		{
			$$ = (YYSTYPE) 1;
		}
	| /* NULL */
		{
			$$ = 0;
		}
	;


opt_index_type
	: /* NULL */
		{
			$$ = (YYSTYPE) IDX_AVL;
		}
	| AVL_INDEX
		{
			$$ = (YYSTYPE) IDX_AVL;
		}
	| CPI_INDEX
		{
			$$ = (YYSTYPE) IDX_CPI;
		}

	;


opt_seq_step
	: /* NULL */
		{
			$$ = (YYSTYPE) 1;
		}
	| STEP NUM
		{
			$$ = (YYSTYPE) (long)atoi((char *)$2);
			memFreeToken($2);
		}
	;

opt_seq_val
	: /* NULL */
		{
			$$ = (YYSTYPE) 1;
		}
	| VALUE NUM
		{
			$$ = (YYSTYPE) (long)atoi((char *)$2);
			memFreeToken($2);
		}
	;



field_list
	: field_list_item
	| field_list ',' field_list_item
	;



field_list_item
	: qual_ident type opt_nullspec opt_keyspec
		{ 
			if(parseAddField((mIdent_t *)$1,(long)$2,
				charArrayLength, notNullFlag, keyFlag,
				curQuery)<0)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
			if (charArrayLength)
			{
				free(charArrayLength);
			}
			charArrayLength = NULL;
		}
	;



type
	: MSQL_INT
		{ 	$$ = (YYSTYPE) INT32_TYPE; }
	| MSQL_INT8
		{ 	$$ = (YYSTYPE) INT8_TYPE; }
	| MSQL_INT16
		{ 	$$ = (YYSTYPE) INT16_TYPE; }
	| MSQL_INT32
		{ 	$$ = (YYSTYPE) INT32_TYPE; }
	| MSQL_INT64
		{ 	$$ = (YYSTYPE) INT64_TYPE; }
	| MSQL_UINT
		{ 	$$ = (YYSTYPE) UINT32_TYPE; }
	| MSQL_UINT8
		{ 	$$ = (YYSTYPE) UINT8_TYPE; }
	| MSQL_UINT16
		{ 	$$ = (YYSTYPE) UINT16_TYPE; }
	| MSQL_UINT32
		{ 	$$ = (YYSTYPE) UINT32_TYPE; }
	| MSQL_UINT64
		{ 	$$ = (YYSTYPE) UINT64_TYPE; }
	| MSQL_DATE
		{ 	$$ = (YYSTYPE) DATE_TYPE; }
	| MSQL_DATETIME
		{ 	$$ = (YYSTYPE) DATETIME_TYPE; }
	| MSQL_MILLITIME
		{ 	$$ = (YYSTYPE) MILLITIME_TYPE; }
	| MSQL_MILLIDATETIME
		{ 	$$ = (YYSTYPE) MILLIDATETIME_TYPE; }
	| MSQL_IPV4
		{ 	$$ = (YYSTYPE) IPV4_TYPE; }
	| MSQL_CIDR4
		{ 	$$ = (YYSTYPE) CIDR4_TYPE; }
	| MSQL_IPV6
		{ 	$$ = (YYSTYPE) IPV6_TYPE; }
	| MSQL_CIDR6
		{ 	$$ = (YYSTYPE) CIDR6_TYPE; }
	| MSQL_MONEY
		{ 	$$ = (YYSTYPE) MONEY_TYPE; }
	| MSQL_TIME
		{ 	$$ = (YYSTYPE) TIME_TYPE; }
	| MSQL_REAL
		{ 	$$ = (YYSTYPE) REAL_TYPE; }
	| MSQL_CHAR '(' NUM ')'
		{ 
			charArrayLength = (char*)$3; 
		 	$$ = (YYSTYPE) CHAR_TYPE; 
		}
	| MSQL_TEXT '(' opt_text_field_len ')'
		{ 
			charArrayLength = (char*)$3; 
		 	$$ = (YYSTYPE) TEXT_TYPE; 
		}
	;

opt_text_field_len
	: NUM 
		{
			$$ = $1;
		}
	| /* NULL */
		{
			$$ = (u_char*)strdup("100");
		}
	;

opt_nullspec
	: /* NULL */	
		{
			notNullFlag = 0;
		}
	| NOT NULLSYM	
		{
			notNullFlag = 1;
		}
	;


opt_keyspec
	: /* NULL */	
		{
			keyFlag = 0;
		}
	| PRIMARY KEY	
		{
			keyFlag = 1;
		}
	;




/*
** Select : retrieve data from table
*/


select
	: MSQL_SELECT opt_distinct select_data into_clause FROM table_list where_clause order_clause limit_clause offset_clause
		{
			curQuery->command = MSQL_SELECT;
		}
	;

opt_distinct
	: /* NULL */
		{ curQuery->selectDistinct = 0; }
	| ALL
		{ curQuery->selectDistinct = 0; }
	| DISTINCT
		{ curQuery->selectDistinct = 1; }
	;



select_data
	: select_data ',' select_item
	| select_item
	| '*'
		{
			mIdent_t	*tmp;

			tmp = parseCreateIdent(NULL,"*", curQuery);
			parseAddField((mIdent_t *)tmp,0,0,0,0, curQuery);
			curQuery->selectWildcard = 1;
		}
	;

select_item
	: qual_ident
		{
			parseAddField((mIdent_t *)$1,0,0,0,0, curQuery);
		}
	| qual_sysvar
		{
			parseAddField((mIdent_t *)$1,0,0,0,0, curQuery);
		}
	| function
	;

function
	: ident 
		{
			if (parseAddFunction((char*)$1, curQuery) < 0)
			{
				memFreeToken($1);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($1);
		}
	  '(' funct_param_list ')' opt_output_name
		{
			if (functFindFunction(curQuery) < 0)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
		}
	;

funct_param_list
	: funct_param_list ',' funct_param
	| funct_param
	;

funct_param
	: qual_ident
		{ 
			parseAddFunctParam((mIdent_t *)$1, curQuery); 
		}
	| qual_sysvar
		{ 
			parseAddFunctParam((mIdent_t *)$1, curQuery); 
		}
	| literal
		{
			parseAddFunctLiteral((mVal_t *)$1, curQuery);
		}
	;

opt_output_name
	: /* NULL */
	| MSQL_TEXT
		{
			parseSetFunctOutputName((char*)$1, curQuery);
			memFreeToken($1);
		}
	;

table_list
	: ident
		{
			if (parseAddTable((char*)$1,NULL,curQuery) < 0)
                        {
                                memFreeToken($1);
                                parseCleanQuery(curQuery);
                                return(-1);
                        }
			memFreeToken($1);
		}
	| ident table_alias ident
		{
			if (parseAddTable((char*)$1, (char*)$3, curQuery) < 0)
			{
				memFreeToken($1);
				memFreeToken($3);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($1);
			memFreeToken($3);
		}
	| table_list ',' ident
		{
			if (parseAddTable((char*)$3, NULL,curQuery) < 0)
			{
				memFreeToken($3);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($3);
		}
	| table_list ',' ident table_alias ident
		{
			if (parseAddTable((char*)$3, (char*)$5, curQuery) < 0)
			{
				memFreeToken($3);
				memFreeToken($5);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($3);
			memFreeToken($5);
		}
	;

table_alias
	: /* NULL */
	| AS
	| EQ
	;

where_clause
	: /* NULL */
	| WHERE cond_list
	;


cond_list
	: cond_list cond_cont cond_field cond_op cond_literal
		{ 
			if ( parseAddCondition((mIdent_t *)$3,(long)$4,
				(mVal_t *)$5, (long)$2, curQuery) < 0)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
		} 
	| cond_list cond_cont cond_field BETWEEN literal AND literal
		{
			parseAddBetween((mIdent_t *)$3, (mVal_t *)$5,
				(mVal_t *)$7, (long)$2,curQuery);
		}
	| cond_list cond_cont sub_cond
		{ 
			parseAddSubCond((long)$2, curQuery); 
		}
	| cond_field cond_op cond_literal
		{ 
			if ( parseAddCondition((mIdent_t *)$1,(long)$2,
				(mVal_t *)$3, NO_BOOL, curQuery) < 0)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
		}
	| cond_field BETWEEN literal AND literal
		{
			parseAddBetween((mIdent_t *)$1, (mVal_t*)$3,
				(mVal_t *)$5, NO_BOOL,curQuery);
		}
	| sub_cond
		{ 	
			parseAddSubCond(NO_BOOL, curQuery); 
		}
	;

sub_cond
	: '(' 
	  	{
			parsePushCondition(curQuery);
		}
	   cond_list ')'
	;


cond_field
	: qual_ident
		{ $$ = $1; }
	| qual_sysvar
		{ $$ = $1; }
	;

cond_cont
	: AND
		{ $$ = (u_char *)AND_BOOL; }
	| OR
		{ $$ = (u_char *)OR_BOOL; }
	;

cond_op
	: EQ
		{ $$ = (u_char *)EQ_OP; }
	| NE
		{ $$ = (u_char *)NE_OP; }
	| LT
		{ $$ = (u_char *)LT_OP; }
	| LE
		{ $$ = (u_char *)LE_OP; }
	| GT
		{ $$ = (u_char *)GT_OP; }
	| GE
		{ $$ = (u_char *)GE_OP; }
	| LIKE
		{ $$ = (u_char *)LIKE_OP; }
	| RLIKE
		{ $$ = (u_char *)RLIKE_OP; }
	| CLIKE
		{ $$ = (u_char *)CLIKE_OP; }
	| SLIKE
		{ $$ = (u_char *)SLIKE_OP; }
	| NOT LIKE
		{ $$ = (u_char *)NOT_LIKE_OP; }
	| NOT RLIKE
		{ $$ = (u_char *)NOT_RLIKE_OP; }
	| NOT CLIKE
		{ $$ = (u_char *)NOT_CLIKE_OP; }
	| NOT SLIKE
		{ $$ = (u_char *)NOT_SLIKE_OP; }
	;


order_clause
	: 
	| ORDER BY order_list
	;

order_list
	: order_list ',' order_ident order_dir
		{ 
			parseAddOrder((mIdent_t *)$3,(long) $4, curQuery); 
		}
	| order_ident order_dir
		{ 
			parseAddOrder((mIdent_t *)$1,(long) $2, curQuery); 
		}
	;

order_dir
	: ASC
		{ $$ = (u_char *) ASC; }
	| DESC
		{ $$ = (u_char *) DESC; }
	| /* NULL */
		{ $$ = (u_char *) ASC; }
	;

limit_clause
	:
		{ 
			curQuery->rowLimit = 0; 
		}
	| LIMIT literal
		{ 	
			parseSetRowLimit((mVal_t *)$2, curQuery); 
			memFreeValue((mVal_t*)$2); /* DJH */
		}
	;

offset_clause
	:
		{ 
			curQuery->rowOffset = 0; 
		}
	| OFFSET literal
		{ 	
			parseSetRowOffset((mVal_t *)$2, curQuery); 
			memFreeValue((mVal_t*)$2); /* DJH */
		}
	;

into_clause
	: 
		{
			parseSetTargetTable(NULL,curQuery);}
	| INTO ident
		{ 
			parseSetTargetTable((char *)$2, curQuery); 
			/* memFreeToken($2); DJH */
		}
	;


/*
** Drop : delete entire table
*/

drop
	: MSQL_DROP drop_types
	;


drop_types
	: TABLE ident
		{
			curQuery->command = DROP_TABLE;
			if (parseAddTable((char*)$2,NULL,curQuery) < 0)
			{
				memFreeToken($2);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($2);
		}
	| INDEX ident FROM ident
		{
			curQuery->command = DROP_INDEX;
			if (parseAddIndex((char*)$2,(char*)$4,0,0,curQuery)<0)
			{
				memFreeToken($2);
				memFreeToken($4);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($2);
			memFreeToken($4);
		}
	| SEQUENCE FROM ident
		{
			curQuery->command = DROP_SEQUENCE;
			parseAddSequence((char*)$3,0,0, curQuery);
			memFreeToken($3);
		}
	;


/*
** Insert : add new data to table
*/

insert
	: MSQL_INSERT INTO ident opt_field_spec 
		{
			curQuery->command = MSQL_INSERT;
			if (parseAddTable((char*)$3,NULL,curQuery) < 0)
			{
				memFreeToken($3);
				parseCleanQuery(curQuery);
				return(-1);
			}
			if ($4)
			{
				utilExpandTableFields(globalServer,(char*)$3,
					curQuery);
			}
			memFreeToken($3);
			parseSetInsertOffset(0);
		}
	  VALUES '(' values ')' opt_bulk_insert
	;


opt_field_spec
	: /* NULL */
		{
			mIdent_t	*tmp;

			tmp = parseCreateIdent(NULL,"*", curQuery);
			parseAddField((mIdent_t *)tmp,0,0,0,0,curQuery);
			$$ = (u_char *) 1;
		}
	| '(' fields ')'
		{
			$$ = (u_char *) 0;
		}
	;


fields
	: fields ',' qual_ident
		{ 
			parseAddField((mIdent_t *)$3,0,0,0,0,curQuery);
		}
	| qual_ident
		{ 
			parseAddField((mIdent_t *)$1,0,0,0,0,curQuery); 
		}
	;



values
	: values ',' literal
		{ 
			parseAddInsertValue((mVal_t *)$3,curQuery);
		 }
	|  literal
		{ 
			parseAddInsertValue((mVal_t *)$1, curQuery); 
		}
	;

opt_bulk_insert
	: /* NULL */
	| ',' '(' 
		{
			parseSetInsertOffset(0);
		}
	  values ')'
		{
		}
	  opt_bulk_insert
	;

/*
** Update : replace a table entry
*/

update
	: MSQL_UPDATE ident SET update_list where_clause
		{
			curQuery->command = MSQL_UPDATE;
			if (parseAddTable((char *)$2,NULL,curQuery) < 0)
			{
				memFreeToken($2);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($2);
		}
	;

update_list
	: update_list ',' qual_ident EQ literal
		{ 	
			parseAddField((mIdent_t *)$3,0,0,0,0,curQuery);
		  	parseAddFieldValue((mVal_t *)$5,curQuery); 
		}
	| qual_ident EQ update_value
		{ 	
			parseAddField((mIdent_t *)$1,0,0,0,0,curQuery);
		  	parseAddFieldValue((mVal_t *) $3, curQuery); 
		}
	;


update_value
	: literal
		{ $$ = $1; }
	| qual_sysvar
		{ $$ = $1; }
	;

/*
** Delete : conditionally delete table entries (or all entries)
*/

delete
	: MSQL_DELETE  FROM ident where_clause limit_clause
		{
			curQuery->command = MSQL_DELETE;
			if (parseAddTable((char *)$3,NULL,curQuery) < 0)
			{
				memFreeToken($3);
				parseCleanQuery(curQuery);
				return(-1);
			}
			memFreeToken($3);
		}
	;


/*
** Common definitions
*/

literal
	: MSQL_TEXT
		{
			$$ = (u_char *)parseCreateValue((u_char*)$1,CHAR_TYPE,
				yytoklen);
			if (yytoklen < NAME_LEN)
				memFreeToken($1);
			else
				free($1);
                        if ($$ == NULL)
                        {
                                parseCleanQuery(curQuery);
                                return(-1);
                        }
		}
	| NUM
		{
			if (*$1 == '-')
			{
				$$ = (u_char *)parseCreateValue((u_char*)$1, 
					INT64_TYPE, 0);
			}
			else
			{
				$$ = (u_char *)parseCreateValue((u_char*)$1, 
					UINT64_TYPE, 0);
			}
			memFreeToken($1);
                        if ($$ == NULL)
                        {
                                parseCleanQuery(curQuery);
                                return(-1);
                        }
		}
	| REAL_NUM
		{
			$$ = (u_char*)parseCreateValue((u_char*)$1,REAL_TYPE,0);
			memFreeToken($1);
                        if ($$ == NULL)
                        {
                                parseCleanQuery(curQuery);
                                return(-1);
                        }
		}
	| NULLSYM
		{
			$$ = (u_char *)parseCreateValue((u_char*)"null",
				NULL_TYPE,0);
		}
	;

cond_literal
	: literal
		{
			$$ = $1;
		}
	| qual_ident
		{
			$$ = (u_char *)parseCreateValue((u_char *)$1,
				IDENT_TYPE,0);
		}
	| qual_sysvar
		{
			$$ = (u_char *)parseCreateValue((u_char *)$1,
				SYSVAR_TYPE,0);
		}
	;



order_ident
	: qual_ident
		{ $$ = $1; }
	| qual_sysvar
		{ $$ = $1; }
	;

qual_ident
	: ident
		{ 
			$$ = (u_char*)parseCreateIdent(NULL,(char*)$1,curQuery);
			memFreeToken($1);
			if ($$ == NULL)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
		}
	| ident '.' ident
		{ 
			$$ = (u_char *)parseCreateIdent((char*)$1,(char*)$3,
				curQuery); 
			memFreeToken($1);
			memFreeToken($3);
			if ($$ == NULL)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
		}
	;

qual_sysvar
	: SYS_VAR
		{ 
			$$ = (u_char*)parseCreateIdent(NULL,(char*)$1,curQuery);
			memFreeToken($1);
			if ($$ == NULL)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
		}
	| ident '.' SYS_VAR
		{ 
			$$ = (u_char *)parseCreateIdent((char*)$1,(char*)$3,
				curQuery); 
			memFreeToken($1);
			memFreeToken($3);
			if ($$ == NULL)
			{
				parseCleanQuery(curQuery);
				return(-1);
			}
		}
	;


ident
	: IDENT 	
		{ 
			$$ = $1; 
		}
	| keyword
		{
			$$=(u_char*)memMallocToken((char*)$1,strlen((char*)$1));
		}
	;

keyword
	: MSQL_CREATE	{ $$ = yytext; }
	| MSQL_DROP	{ $$ = yytext; }
	| MSQL_INSERT	{ $$ = yytext; }
	| MSQL_DELETE	{ $$ = yytext; }
	| MSQL_SELECT	{ $$ = yytext; }
	| MSQL_UPDATE	{ $$ = yytext; }

	| ALL		{ $$ = yytext; }
	| DISTINCT	{ $$ = yytext; }
	| AS		{ $$ = yytext; }

	| WHERE		{ $$ = yytext; }
	| ORDER		{ $$ = yytext; }
	| FROM		{ $$ = yytext; }
	| INTO		{ $$ = yytext; }
	| TABLE		{ $$ = yytext; }
	| BY		{ $$ = yytext; }
	| ASC		{ $$ = yytext; }
	| DESC		{ $$ = yytext; }
	| LIKE		{ $$ = yytext; }
	| RLIKE		{ $$ = yytext; }
	| CLIKE		{ $$ = yytext; }
	| SLIKE		{ $$ = yytext; }
	| AND		{ $$ = yytext; }
	| OR		{ $$ = yytext; }
	| VALUES	{ $$ = yytext; }
	| SET		{ $$ = yytext; }

	| NOT		{ $$ = yytext; }

	| PRIMARY	{ $$ = yytext; }
	| KEY		{ $$ = yytext; }
	| INDEX		{ $$ = yytext; }
	| UNIQUE	{ $$ = yytext; }
	| ON		{ $$ = yytext; }

	| MSQL_INT	{ $$ = yytext; }
	| MSQL_INT8	{ $$ = yytext; }
	| MSQL_INT16	{ $$ = yytext; }
	| MSQL_INT32	{ $$ = yytext; }
	| MSQL_INT64	{ $$ = yytext; }
	| MSQL_UINT	{ $$ = yytext; }
	| MSQL_UINT8	{ $$ = yytext; }
	| MSQL_UINT16	{ $$ = yytext; }
	| MSQL_UINT32	{ $$ = yytext; }
	| MSQL_UINT64	{ $$ = yytext; }
	| MSQL_BOOL	{ $$ = yytext; }
	| MSQL_CHAR	{ $$ = yytext; }
	| MSQL_REAL	{ $$ = yytext; }
	| MSQL_DATE	{ $$ = yytext; }
	| MSQL_DATETIME	{ $$ = yytext; }
	| MSQL_MILLITIME	{ $$ = yytext; }
	| MSQL_MILLIDATETIME	{ $$ = yytext; }
	| MSQL_MONEY	{ $$ = yytext; }
	| MSQL_TIME	{ $$ = yytext; }
	| MSQL_IPV4	{ $$ = yytext; }
	| MSQL_CIDR4	{ $$ = yytext; }
	| MSQL_IPV6	{ $$ = yytext; }
	| MSQL_CIDR6	{ $$ = yytext; }
	| LIMIT		{ $$ = yytext; }
	| OFFSET	{ $$ = yytext; }
	| SEQUENCE	{ $$ = yytext; }
	| VALUE		{ $$ = yytext; }
	| STEP		{ $$ = yytext; }
	;
